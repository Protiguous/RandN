<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
<#
var types = new (Type type, Type unsigned, Type ularge)[]
{
    (typeof(SByte), typeof(Byte), typeof(UInt32)),
    (typeof(Int16), typeof(UInt16), typeof(UInt32)),
    (typeof(Int32), typeof(UInt32), typeof(UInt32)),
    (typeof(Int64), typeof(UInt64), typeof(UInt64)),
    (typeof(Byte), typeof(Byte), typeof(UInt32)),
    (typeof(UInt16), typeof(UInt16), typeof(UInt32)),
    (typeof(UInt32), typeof(UInt32), typeof(UInt32)),
    (typeof(UInt64), typeof(UInt64), typeof(UInt64)),
};
#>
using System;

/*** This file is auto generated - any changes made here will be lost. ***/
namespace RandN.Distributions
{
        /// <summary>
        /// Contains methods to create instances of <see cref="UniformInt{T}" />.
        /// </summary>
    internal static class UniformInt
    {
<# foreach (var param in types)
{
    String type = param.type.Name;
    String unsigned = param.unsigned.Name;
    String ularge = param.ularge.Name;
#>
        /// <summary>
        /// Creates a <see cref="UniformInt{<#= type #>}" /> with an exclusive upper bound. Should not
        /// be used directly; instead, use <see cref="Uniform.New(<#= type #>, <#= type #>)" />.
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="low"/> is greater than or equal to <paramref name="high"/>.
        /// </exception>
        public static UniformInt<<#= type #>> Create(<#= type #> low, <#= type #> high)
        {
            if (low >= high)
                throw new ArgumentOutOfRangeException(nameof(high), $"{nameof(high)} ({high}) must be higher than {nameof(low)} ({low}).");

            return CreateInclusive(low, (<#= type #>)(high - 1));
        }
        

        /// <summary>
        /// Creates a <see cref="UniformInt{<#= type #>}" /> with an exclusive lower bound. Should not
        /// be used directly; instead, use <see cref="Uniform.NewInclusive(<#= type #>, <#= type #>)" />.
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="low"/> is greater than <paramref name="high"/>.
        /// </exception>
        public static UniformInt<<#= type #>> CreateInclusive(<#= type #> low, <#= type #> high)
        {
            if (low > high)
                throw new ArgumentOutOfRangeException(nameof(high), $"{nameof(high)} ({high}) must be higher than or equal to {nameof(low)} ({low}).");

            var unsignedMax = <#= ularge #>.MaxValue;
            var range = unchecked((<#= ularge #>)(high - low + 1));
            var intsToReject = range == 0 ? 0 : (unsignedMax - range + 1) % range;

            return new UniformInt<<#= type #>>(low, range, (<#= unsigned #>)intsToReject);
        }
<#
}
#>
    }

    /// <summary>
    /// Implements a Uniform <see cref="IDistribution{TResult}"/> for integral types such as <see cref="Int32" /> and <see cref="UInt64" />.
    /// Use of any other type results in a runtime exception.
    /// </summary>
    public readonly struct UniformInt<T> : IPortableDistribution<T>
        // We're extremely restrictive here to discourage people from trying to use unsupported types for T
        where T : struct, IComparable, IComparable<T>, IConvertible, IEquatable<T>, IFormattable
    {
        private readonly T _low;
        private readonly UInt64 _range;
        private readonly UInt64 _zone;
        
        internal UniformInt(T low, UInt64 range, UInt64 zone)
        {
            _low = low;
            _range = range;
            _zone = zone;
        }

        /// <inheritdoc />
        public T Sample<TRng>(TRng rng) where TRng : notnull, IRng
        {
<# foreach (var param in types)
{
    String type = param.type.Name;
#>
            if (typeof(T) == typeof(<#= type #>))
                return (T)(Object)Sample<#= type #>(rng);
<#
}
#>
            throw new NotSupportedException($"Type {typeof(T)} is not supported.");
        }

        /// <inheritdoc />
        public Boolean TrySample<TRng>(TRng rng, out T result) where TRng : notnull, IRng
        {
<# foreach (var param in types)
{
    String type = param.type.Name;
#>
            if (typeof(T) == typeof(<#= type #>))
            {
                Boolean success = TrySample<#= type #>(rng, out var temp);
                result = (T)(Object)temp;
                return success;
            }
<#
}
#>
            throw new NotSupportedException($"Type {typeof(T)} is not supported.");
        }
        
<# foreach (var param in types)
{
    String type = param.type.Name;
    String unsigned = param.unsigned.Name;
    String ularge = param.ularge.Name;
#>
        private <#= type #> Sample<#= type #><TRng>(TRng rng) where TRng : notnull, IRng
        {
            var low = (<#= type #>)(Object)_low;
            var range = (<#= ularge #>)_range;
            var unsigned = rng.Next<#= ularge #>();
            if (range == 0) // 0 is a special case where we sample the entire range.
                return (<#= type #>)unsigned;

            var zone = <#= ularge #>.MaxValue - _zone;

            while (unsigned > zone)
            {
                unsigned = rng.Next<#= ularge #>();
            }

            return unchecked((<#= type #>)((<#= type #>)(unsigned % range) + low));
        }

        private Boolean TrySample<#= type #><TRng>(TRng rng, out <#= type #> result) where TRng : notnull, IRng
        {
            var low = (<#= type #>)(Object)_low;
            var range = (<#= ularge #>)_range;
            var unsigned = rng.Next<#= ularge #>();
            if (range == 0) // 0 is a special case where we sample the entire range.
            {
                result = (<#= type #>)unsigned;
                return true;
            }

            var zone = <#= ularge #>.MaxValue - _zone;

            if (unsigned <= zone)
            {
                result = unchecked((<#= type #>)((<#= type #>)(unsigned % range) + low));
                return true;
            }

            result = default;
            return false;
        }
<#
}
#>
    }
}
